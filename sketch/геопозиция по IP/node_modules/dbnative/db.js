"use strict"
const MongoClient = require('mongodb').MongoClient;
module.exports = class db {
  constructor(options, cb) {
    let ref = this;
    ref.mongoUrl = 'mongodb://localhost:27017/';
    if (options.host && options.port)
      ref.mongoUrl = 'mongodb://' + options.host + ':' + options.port + '/'
    else if (options.host)
      ref.mongoUrl = 'mongodb://' + options.host + ':27017/'
    ref.mongoUrl += options.dbName;
  }
  init() {
    let ref = this;
    return new Promise(function(res, reject) {
      MongoClient.connect(ref.mongoUrl, function(err, dbs) {
        ref.db = dbs;
        console.log("DataBase : " + ref.mongoUrl + " Connected");
        res();
      })
    })
  }
  save(data, collectionName, callback) {
    let ref = this;
    try {
      ref.db.collection(collectionName).save(data);
      if (callback)
        callback(true);
    } catch (err) {
      console.log(err);
      if (callback)
        callback(false);
    }
  }

  saveMulti(data, collectionName, callback) {
    let ref = this;
    data.forEach(function(value, i, array) {
      ref.save(value, collectionName, function() {
        if (i == array.length - 1) {
          if (callback)
            callback()
        }
      })
    })
  }

  update(findQuery, setQuery, upsert, collectionName, callback) {
    let ref = this;
    try {
      ref.db.collection(collectionName).update(findQuery, setQuery, {
        upsert: upsert
      })
      if (callback)
        callback(true)
    } catch (err) {
      if (callback)
        callback(false)
    }
  }

  find(options, collectionName, callback) {
    let ref = this;
    try {
      ref.db.collection(collectionName).find(options.find ? options.find : {}).sort(options.sort ? options.sort : {}).skip(options.skip ? options.skip : 0).limit(options.limit ? options.limit : 0).toArray(function(err, item) {
        if (callback)
          callback(item)
      })
    } catch (err) {
      if (callback)
        callback(false)
      console.log(err);
    }
  }

  aggregate(pipeline, collectionName, callback) {
    let ref = this;
    try {
      ref.db.collection(collectionName).aggregate(pipeline).toArray(function(err, result) {
        callback(result);
      });
    } catch (err) {
      callback(false)
      console.log(err);
    }
  }
}
